firmware/dircache.c
    dircache_init(): buffer_alloc for each d_name in the opendirs array
        * the opendirs dirs array is statically allocated, there's no
        reason the d_name in it shouldn't also;
        * reason for buffer_alloc() is probably that d_name needs to be a pointer
    dircache_load(): first buffer_alloc(0) to determine the start of buffer
        * this is in within HAVE_EEPROM_SETTINGS, the first buffer_alloc()
          is to check whether the buffer start matches the buffer start
          in the dump on disk, if it it is the dump is loaded to memory as-is,
          otherwise dircache is fully reinitialized
        * this relies on reproducable boots (identical buffer_alloc() calls) and
          determininistic buffers from buffer_alloc(). This should work with
          buflib also. In any event, it only affects HAVE_EEPROM_SETTINGS (h100?)
          and it's probably non-fatal if it doesn't work anymore
    *dircache_build(): buffer_alloc()s if the dircache size is known (e.g.
          from previous boots), otherwise audiobuf is accessed directly.
        * in the first case, the buffer size is known and allocated,
          followed by a "transparent build" (i.e. in background);
          should be easily replacable with buflib
        * in the second case, the buffer size is unknown and a foreground
          build is started; this relies on no other thread being able temop to
          run for exclusive access; not possible with current buflib
            -> need to implement some buflib_get_all() which may possibly
            resizeable/reallocable
          (see also dircache_do_rebuild())
    usage of the allocation:
        if not buffer_alloc()d, it's only temporarilly used, probably no
        concurrent access (CA) issues (that or it would be completely
        broken currently)
        if buffer_alloc()'d, then the buffer is used throughout runtime to
        allocate dircache_entry structs and the d_name member of it (separately,
        d_name is allocated as needed); access happens via dircache_root and
        offset (dirache_root+dircache_size, etc)
    considerations for compaction
        dircache.c itself can probably handle compation just fine, since
        it's using an offset-to-pointer mechanism already and keeps track
        of all sub-allocations (via dircache_entry->next etc)
        however, dircache_get_entry_ptr() exports dircache_entrys (and thus d_names)
        from the buffer to the caller for unknown time; therefore compaction
        of this buffer is not always safe :(
        Additionally, a pointer to a dircache_entry is saved in DIR_CACHED,
        every DIR_CACHED is from the opendirs array (local to dircache.c)
        and they have a busy flag; DIR_CACHED is opaque for callers (so
        no direct dircache_entry access) and d_name is copied to separately
        allocated storage
        -> this perhaps needs a
        lock, user supplied buffer to copy the entry or invalidation (need
        to analyze the callers more; only tagcache.c and playlist.c so far)
apps/dsp.c
    dsp_timestretch_enable(): buffer_alloc() on boot, and only if timestretch
        is enabled. size is fixed.
    usage:
        the buffer is used for resamping, depending on timestretch.
        resample_buf is toggled between small_resample_buf and big_resample_buf.
        It's then used only used in resample(), apparently without yield().
    compaction:
        resample() doesn't know if it's a buflib buffer or a static
        buffer, so buflib_get_data() doesn't seem possible; but the compaction
        callback can detect this and act accordingly. Since resample() doesn't
        yield no CA is expected and compation should work without much hassle.

        Alternatively small_resample_buf could be made a buflib allocation as
        well, as it's unused if timestretch is enabled. Then resample()
        could call buflib_get_data() unconditionally. However, for speed,
        small_resample_buf is allocated in IRAM so it has a downside.
        (buflib allocs from IRAM with a separate buflib_context perhaps?).
apps/filetypes.c
    filetypes_strdup(): buffer_alloc() for each call. It allocates a string
        buffer for the argument to hold a copy (i.e. like standard strdup)
        It is called from filetypes_store_plugin() and read_config(),
        each only called from filetypes_init(). It's probably called often,
        for tiny sizes, which is not ideal for buflib.
    usage:
        The buffer is used for the in-memory representation of viewers.config,
        setup at boot. the result of filetypes_strdup() is stored in
        in filetypes array. No pointers are exposed to other modules,
        except in openwith_get_name(), which is pretty safe as it's called
        by the list drawing (if it was unsafe, it could be copied into the buffer
        passed to openwith_get_name()).
    compaction:
        The filetypes array could safe the ids instead of raw pointers,
        the buffer is almost exclusively used in filetypes.c (see usage),
        so buflib_get_data() calls should work just fine. But the filetypes
        array can also walked through in the compaction callback. Compaction
        should be no issue here, but the tiny allocations are suboptimal.
apps/skin_engine.c
    theme_init_buffer(): On native targets, buffer_alloc() the skin buffer with
        a fixed size. The function is only called on boot in init(). It seems
        to be replacable by a static allocation. On application targets malloc()
        is used and thus isn't relevant for buflib.
    usage: The skin engine has it's own memory management. One can allocate
        from the skin buffer with skin_buffer_alloc() which returns a pointer
        It's then up to the skin element what happens with that, it very probably
        creates cross references (CR) into the buffer. The memory is also
        exposed to other modules, such as in the backdrop case.
        The skin buffer is reset upon theme (re)loading.
    compaction: It looks like very extensive changes are needed in the skin
        engine. Both CR and exposure to other modules are complicating
        compaction.
        This needs more looking, but for now it seems the easiest to replace
        buffer_alloc() with a static allocation.
